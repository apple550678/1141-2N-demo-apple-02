### w14

```
page

'use client' // Next.js 必備：宣告這是客戶端元件

import { useState, useEffect } from 'react'
import { nanoid } from 'nanoid' // 一個小工具，專門用來產生獨一無二的亂數 ID
import { ToastContainer, toast } from 'react-toastify' // 用來跳出提示訊息的套件
import Form_xx from './_components/Form_xx'
import Items_xx from './_components/Items_xx'
import Wrapper from '../_assets/wrapper/Grocery_xx'

// --- [功能 1] 從瀏覽器讀取舊資料 ---
// 因為 Next.js 會先在伺服器跑一次，伺服器沒有 window (瀏覽器視窗)，所以要先檢查
const getLocalStorage = () => {
  if (typeof window !== 'undefined') {
    let list = localStorage.getItem('list') // 去看 LocalStorage 有沒有存過 'list'
    if (list) {
      list = JSON.parse(list) // 有的話，把 JSON 字串變回陣列
    } else {
      list = [] // 沒有的話，就給一個空陣列
    }
    return list
  }
  return [] // 伺服器端預設回傳空陣列，避免報錯
}

// --- [功能 2] 把資料存進瀏覽器 ---
const setLocalStorage = (items) => {
  localStorage.setItem('list', JSON.stringify(items)) // 把陣列變成字串存起來
}

const GroceryPage_02 = () => {
  // 這裡先給空陣列，等 useEffect 執行時再去讀取舊資料
  const [items, setItems] = useState([])

  // --- [生命週期] 網頁一打開時執行一次 ---
  useEffect(() => {
    const storedList = getLocalStorage() // 去拿舊資料
    if (storedList.length > 0) {
      setItems(storedList) // 如果有舊資料，就更新狀態
    }
  }, [])

  // --- [動作 A] 新增項目 (給 Form 用) ---
  const addItem = (itemName) => {
    const newItem = {
      name: itemName,
      completed: false, // 預設還沒買(未完成)
      id: nanoid(),     // 產生一個 ID，例如 "v1StGXR8"
    }
    const newItems = [...items, newItem] // 把舊陣列(...)跟新項目放在一起
    setItems(newItems)       // 更新畫面
    setLocalStorage(newItems) // 同步存檔
    toast.success('Item added successfully!') // 跳綠色勾勾提示
  }

  // --- [動作 B] 編輯項目/打勾 (給 SingleItem 用) ---
  const editItem = (itemId) => {
    const newItems = items.map((item) => {
      // 找到那個被點擊的 item
      if (item.id === itemId) {
        // ...item 代表保留原本的名字和 ID，只把 completed 變成相反 (true變false)
        const newItem = { ...item, completed: !item.completed }
        return newItem
      }
      return item // 其他沒被點到的 item 原封不動
    })
    setItems(newItems)
    setLocalStorage(newItems)
  }

  // --- [動作 C] 刪除項目 (給 SingleItem 用) ---
  const removeItem = (itemId) => {
    // filter 是過濾：留下 ID 「不等於」要刪除 ID 的項目 (等於是把那個 ID 踢掉)
    const newItems = items.filter((item) => item.id !== itemId)
    setItems(newItems)
    setLocalStorage(newItems)
    toast.warning('item deleted') // 跳黃色警告提示
  }

  return (
    <Wrapper>
      <section className='section-center'>
        {/* 放一個容器在這，讓 toast 訊息有地方跳出來 */}
        <ToastContainer position='top-center' autoClose={3000} />

        {/* 把 addItem 這個工具傳給 Form，讓它等等可以呼叫 */}
        <Form_xx addItem={addItem} />

        {/* 把資料(items)和工具(editItem, removeItem)都傳給列表 */}
        <Items_xx items={items} editItem={editItem} removeItem={removeItem} />
      </section>
    </Wrapper>
  )
}
export default GroceryPage_02
```

```
form

'use client'

import { useState } from 'react'
import { toast } from 'react-toastify'

const Form_xx = ({ addItem }) => {
  // 這個狀態只屬於 Form 自己，用來控制 input 的內容
  const [newItemName, setNewItemName] = useState('')

  const handleSubmit = (e) => {
    e.preventDefault() // 防止表單送出後網頁重新整理

    // 檢查有沒有輸入內容
    if (!newItemName) {
      toast.error('please enter value')
      return
    }

    // 呼叫爸爸 (Page) 給的 addItem 函式，把名字傳回去
    addItem(newItemName)

    // 清空輸入框
    setNewItemName('')
  }

  return (
    <form onSubmit={handleSubmit}>
      <h4>grocery bud</h4>
      <div className='form-control'>
        <input
          type='text'
          className='form-input'
          value={newItemName}
          onChange={(e) => setNewItemName(e.target.value)} // 雙向綁定
        />
        <button type='submit' className='btn'>
          add item
        </button>
      </div>
    </form>
  )
}
export default Form_xx

```

```
items

import SingleItem_xx from './SingleItem_xx'

const Items_xx = ({ items, editItem, removeItem }) => {
  return (
    <div className='items'>
      {/* 跑迴圈：把陣列裡的每一個 item 變成一個元件 */}
      {items?.map((item) => {
        return (
          <SingleItem_xx
            key={item.id} // React 列表渲染必備的唯一鑰匙
            item={item}   // 把單筆資料傳下去
            editItem={editItem} // 把編輯功能傳下去
            removeItem={removeItem} // 把刪除功能傳下去
          />
        )
      })}
    </div>
  )
}
export default Items_xx
```

```
singleitem

const SingleItem_xx = ({ item, editItem, removeItem }) => {
  return (
    <div className='single-item'>
      {/* 核取方塊 Checkbox */}
      <input
        type='checkbox'
        checked={item.completed} // 根據資料決定有沒有打勾
        // 點擊時，呼叫爺爺 (Page) 的 editItem，並把自己的 ID 傳回去
        onChange={() => editItem(item.id)}
      />

      {/* 物品名稱 */}
      <p
        style={{
          textTransform: 'capitalize',
          // 如果 completed 是 true，就加上刪除線 (line-through)
          textDecoration: item.completed && 'line-through',
        }}
      >
        {item.name}
      </p>

      {/* 刪除按鈕 */}
      <button
        className='btn remove-btn'
        type='button'
        // 點擊時，呼叫爺爺 (Page) 的 removeItem，並把自己的 ID 傳回去
        onClick={() => removeItem(item.id)}
      >
        delete
      </button>
    </div>
  )
}
export default SingleItem_xx
```
